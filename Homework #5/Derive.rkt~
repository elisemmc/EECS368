#lang racket

(define (symderiv qf) `(λ ,(cadr qf) ,(symderivat(caadr qf) (caddr qf))))
(define (symderivat v e)
  (cond((symbol? e) (if(eq? v e) 1 0))
       ((not(pair? e)) 0)
       ((not(pair? (cdr e))) 0)
       (else (let((f (cadr e)))
               (case (car e)
                 ((+ -) (cons(car e) (map(λ(x) (symderivat v x))(cdr e))))
                 ((*) (cons '+ (map(λ(x) `(* ,(symderivat v x) ,@(remv x(cdr e))))(cdr e))))
                 ((/) (if(pair?(cddr e))
                         (symderivat v `(* ,f(/(* ,@(cddr e)))))
                         `(/ ,(symderivat v f) -1 (expt ,f 2))))
                 ((exp) `(* ,e ,(symderivat v f)))
                 ((log) `(/ ,(symderivat v f) ,f))
                 ((expt) `(* ,e ,(symderivat v `(* ,(caddr e) (log f)))))
                 ((sin) `(*(cos ,f) ,(symderivat v f)))
                 ((cos) `(* -1 (sin ,f) ,(symderivat v f)))
                 ((tan) `(/ ,(symderivat v f)(expt(cos ,f) 2)))
                 ((asin) `(/ ,(symderivat v (cadr e)) (expt(- 1(expt ,f 2))1/2)))
                 ((acos) `(/(- ,(symderivat v f))(expt(- 1(expt ,f 2))1/2)))
                 ((atan) (if (null?(cddr e))
                            `(/ ,(symderivat v f)(+ 1(expt ,f 2)))
                            (symderivat v `(atan(/ ,f ,(caddr e))))))
                 ((abs) `(*(/ ,f ,e),(symderivat v f)))
                 (else 'ERROR))))))
    
(provide (all-defined-out))